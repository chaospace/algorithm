/**

N개의 정수로 구성된 배열 A가 주어집니다.
연속 N일 동안 주식의 일일 가격을 포함합니다.
단일 주식을 P일에 매수하고 Q일에 매도한 경우(0 ≤ P ≤ Q < N) 해당 거래의 이익 은 A[Q] − A[P]와 같습니다.
단, A[Q] ≥ A[P]. 그렇지 않으면 트랜잭션은 A[P] − A[Q]의 손실 을 가져옵니다.

예를 들어 다음과 같은 6개의 요소로 구성된 다음 배열 A를 고려하십시오.
  A[0] = 23171
  A[1] = 21011
  A[2] = 21123
  A[3] = 21366
  A[4] = 21013
  A[5] = 21367
주식을 0일에 사고 2일에 매도하면 A[2] − A[0] = 21123 − 23171 = −2048이므로 2048의 손실이 발생합니다.
주식을 4일에 사고 5일에 매도하면 A[5] − A[4] = 21367 − 21013 = 354이므로 354의 이익이 발생합니다.
가능한 최대 이익은 356입니다. 1일에 사서 5일에 팔았다.

함수를 작성하고

기능 솔루션(A);

연속 N일 동안 주식의 일일 가격을 포함하는 N개의 정수로 구성된 배열 A가 주어지면
이 기간 동안 한 번의 거래에서 가능한 최대 이익을 반환합니다.
이익을 얻을 수 없는 경우 함수는 0을 반환해야 합니다.

예를 들어 다음과 같은 6개의 요소로 구성된 배열 A가 있다고 가정합니다.

  A[0] = 23171
  A[1] = 21011
  A[2] = 21123
  A[3] = 21366
  A[4] = 21013
  A[5] = 21367
함수는 위에서 설명한 대로 356을 반환해야 합니다.

다음 가정에 대한 효율적인 알고리즘을 작성 하십시오.

N은 [ 0 ..400,000 ] 범위 내의 정수 이고 ;
배열 A의 각 요소는 [ 0 .. 200,000 ] 범위 내의 정수 입니다.
 */

/**
 * 주식 가격이 사고 팔때 수익이 가장 큰 구간 찾기
 * 조건
 *  - 사는 날이 파는 날보다 클 수는 없다.( 배열 조작 안됨 )
 * @param {*} A
 */
function solution(A) {
  //A.sort((a, b) => a - b);
  let buyValue = Number.MAX_SAFE_INTEGER;
  let profit = Number.MIN_SAFE_INTEGER;
  for (let i = 0; i < A.length; i++) {
    buyValue = Math.min(buyValue, A[i]);
    profit = Math.max(profit, A[i] - buyValue);
  }
  console.log(profit, buyValue);
  return profit;
}

console.log(solution([23171, 21011, 21123, 21366, 21013, 21367]));
