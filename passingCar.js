/*

N개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다.
배열 A의 연속 요소는 도로의 연속 차량을 나타냅니다.

배열 A에는 0 및/또는 1만 포함됩니다.

0은 동쪽으로 이동하는 자동차를 나타내고,
1은 서쪽으로 이동하는 자동차를 나타냅니다.
목표는 지나가는 차를 세는 것입니다. 
P가 동쪽으로,
Q가 서쪽으로 갈 때 
0 ≤ P < Q < N인 한 쌍의 자동차(P, Q)가 지나간다고 합니다.

예를 들어 다음과 같은 어레이 A를 고려하십시오.
  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1
(0, 1), (0, 3), (0, 4), (2, 3), (2, 4)의 다섯 쌍의 지나가는 자동차가 있습니다.


N 정수의 비어 있지 않은 배열 A가 주어지면 지나가는 자동차 쌍의 수를 반환합니다.

지나가는 자동차 쌍의 수가 1,000,000,000을 초과하면 함수는 -1을 반환해야 합니다.

예를 들면 다음과 같습니다.

  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1
함수는 위에서 설명한 대로 5를 반환해야 합니다.

다음 가정에 대한 효율적인 알고리즘을 작성 하십시오.

N은 범위 [ 1 .. 100,000 ] 내의 정수 이고;
배열 A의 각 요소는 0, 1 값 중 하나를 가질 수 있는 정수입니다.

*/

/**
 * 0이 나온 인덱스 후에 모든 1을 조합 시킨다.
 * @param {*} cars
 * @returns
 */
function solution(cars) {
  let count = 0;
  let westCar = 0;
  for (let i = cars.length - 1; i >= 0; i--) {
    if (cars[i] === 0) {
      count += westCar;
    } else {
      westCar++;
    }
  }

  console.log("sum", westCar, count);
  return count;
}

//console.log(solution([0, 1, 0, 1, 1]));
console.log(solution([0, 1, 1, 0, 1, 1, 1]));
