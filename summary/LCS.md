# LCS(Longest Common Subsequence) 찾기

## 문제

2개의 문자열이 주어집니다. 이둘의 공통된 가장 긴 문자열을 찾으시오.
공통된 문자열은 서로 왼쪽에서 오른쪽으로 이어져야 하며, 한 문자열 내에서 꼭 근접한 문자들을 고르지 않아도 됩니다.
예를 들어 "abc", "abg", "bdf", "aeg", "acefg", ...등은 'abcdefg"의 부분 문자열입니다.( "gfe"는 거꾸로 적혔으니 안됩니다.)

이 문제는 컴퓨터과학 문제중 가장 기본적인 문제면서도 diff라는 두 파일을 비교하는 프로그래밍을 만드는데 가장 핵심이 됩니다.

## 솔루션

1. 최적의 서브구조 :
   - 주어진 문자열의 길이를 각각 m, n이라 하고 문자열을 배열로 표현하자면 x[0...m-1], y[0...n-1] 가 된다고 가정.
   - L( x[0...m-1], y[0...n-1] )는 두 문자열 x와 y의 LCS의 길이를 반환하는 함수.

만약 두 문자열의 마지막 문자가 같다면( 또는 x[m-1] === y[n-1])

- L( x[0...m-1], y[0...n-1] ) = 1 + L( x[0...m-2], y[0...n-2] ) 가 성립.
- 즉, 뒤에서 부터, 같은 문자열을 찾으면, LCS의 길이를 1증가시키고 각 문자열을 하나씩 줄인뒤 다시 LCS를 찾는 재귀형식으로 접근하는 것입니다.

만약 두 문자열의 길이가 같지 않다면( 또는 x[m-1] != y[n-1] )

- L( x[0...m-1], y[0...n-1] ) = MAX( L( x[0...m-2], y[0...n-1] ), L( x[0...m-1], y[0...n-2] ) ) 가 성립
- 즉, 서로 문자가 같지 않으므로 다음으로 넘어가야 하는데, 두 문자열중 하나만 다음으로 넘어가고 하나는 그대로 냅두는 방법을 택합니다. 그래서 한쪽의 문자열 길이는 -1이 되고 ( m-1 -> m-2 ), 한 쪽은 그래도 유지됩니다.( n-1 -> n-1 ). 그리고 그 문자열들 중에 LCS를 다시 찾아서 가장 긴 문자열을 찾습니다.(Max)

## 예제

<code>"AGGTAB"</code>와 <code>"GXTXAYB"</code>가 LCS를 구해야할 두 개의 문자열이라고 가정.( 마지막 문자 'B'가 서로 같음. ) 위에서 정리한 공식을 이용하면

> L( x[0...m-1], y[0...n-1]) = 1 + L( x[0...m-2], y[0...n-2] )

로 쓸 수 있고, 이것은 다시

> L ("AGGTAB", "GXTXAYB" ) = 1 + L ( "AGGTA" , "GXTXAY" )

로 표현할 수 있습니다.

|                    | A   | G   | **<code>G</code>** | **<code>T</code>** | **<code>A</code>** | **<code>B</code>** |
| ------------------ | --- | --- | ------------------ | ------------------ | ------------------ | ------------------ |
| **<code>G</code>** | -   | -   | 4                  | -                  | -                  | -                  |
| X                  | -   | -   | -                  | -                  | -                  | -                  |
| **<code>T</code>** | -   | -   | -                  | 3                  | -                  | -                  |
| X                  | -   | -   | -                  | -                  | -                  | -                  |
| **<code>A</code>** | -   | -   | -                  | -                  | 2                  | -                  |
| Y                  | -   | -   | -                  | -                  | -                  | -                  |
| **<code>B</code>** | -   | -   | -                  | -                  | -                  | 1                  |

서로 다른 문자열을 찾는 예시  
<code>"ABCDGH"</code>와 <code>"AEDFHR"</code>가 LCS를 구해야할 두 개의 문자열이라고 가정.  
문자열의 마지막 "H" 와 "R"로 서로 매칭이 안됩니다. 위에서 언급한 공식을 적용하면

> L( x[0...m-1], y[0...n-1] ) = Max( L( x[0...m-2], y[0...n-1] ), L( x[0...m-1], y[0...n-2] ) )

로 쓸 수 있고, 이것은 다시

> L ( "ABCDGH", "AEDFHR" ) = Max( L( "ABCDG", "AEDFHR" ), L( "ABCDGH", "AEDFH" ) )

로 표현할 수 있습니다.

위 내용으로 미루어, LCS문제는 서브 LCS문제의 솔루션을 이용해서 풀릴 수 있다는 점이 "최적의 서브구조"성질을 만족함을 알수 있다.

### 서브루틴 최적화

위 내용을 코드로 풀어보면 아래와 같다.

```javascript
function lcs(x, y, m, n) {
  // 마지막일 경우
  if (m === 0 || n === 0) {
    return 0;
    // 마지막 문자가 같을 경우
  } else if (x[m - 1] === y[n - 1]) {
    return 1 + lcs(x, y, m - 1, n - 1);
  } else {
    return Math.max(lcs(x, y, m, n - 1), lcs(x, y, m - 1, n));
  }
}
```
