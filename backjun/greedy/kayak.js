/**
 * 카약
 * 상근이는 카약 대회를 개최했다. 그런데, 갑자기 엄청난 강풍이 경기장에 불었고, 일부 카약이 부서졌다.
 * 경기는 5분 안에 시작해야 하는 상황이다.
 * 다행히 일부 팀은 혹시 모를 사태에 대비해서 카약을 하나 더 경기장에 들고 왔다.
 * 카약은 매우 무겁고 운반하기 어렵다. 따라서, 자신의 바로 다음이나 전에 경기하는 팀에게만 카약을 빌려주려고 한다.
 * 즉, 팀 4는 여분의 카약을 3이나 5에게만 빌려줄 수 있다.
 * 다른 팀에게서 받은 카약은 또 다른 팀에게 빌려줄 수 없다.
 * 또, 카약을 하나 더 가져온 팀의 카약이 손상되었다면, 여분의 카약으로 경기에 출전하게되고,
 * 이 카약은 다른 팀에게 빌려줄 수 없다.
 * 카약이 부서진 팀과 하나 더 가져온 팀이 주어진다.
 * 카약을 적절히 빌렸을 때 출발하지 못하는 팀의 최솟값은 몇 팀인지 구하는 프로그램을 작성하시오.
 *
 * 카약의 대여는 자신의 앞뒤로만 가능.
 * 빌린 카약은 다시 대여 불가.
 *
 * 입력:
 * 첫째 줄에 팀의 수 N, 카약이 손상된 팀의 수 S, 카약을 하나 더 가져온 팀의 수 R이 주어진다.
 * (2 ≤ N ≤ 10, 1 ≤ S, R ≤ N)
 * 둘째 줄에는 카약이 손상된 팀의 번호가 주어진다. 팀 번호는 중복되지 않는다.
 * 셋째 줄에는 카약을 하나 더 가져온 팀의 번호가 주어진다. 팀 번호는 중복되지 않는다.
 *
 * 5 2 1
 * 2 4
 * 3
 *
 * 아웃풋:
 * 1 ( 3번 팀은 2, 4번에 대여가 가능하고 이를 제거한 후에는 2, 혹은 4 하나만 남아서 출전 못하는 팀은 1)
 */

function solution({ n, s, r }) {
  /**
   * s에 length가 결국 답.
   */
  while (r.length && s.length) {
    let c = r.shift();
    const left = s.indexOf(c - 1);
    const right = s.indexOf(c + 1);
    if (left >= 0) {
      s.splice(left, 1);
    } else if (right >= 0) {
      s.splice(right, 1);
    }
  }
  return {
    answer: s.length,
    s,
    r,
  };
}

[
  {
    n: 5,
    s: [2, 4],
    r: [3],
  },
  {
    n: 5,
    s: [2, 4],
    r: [1, 3, 5],
  },
].forEach((info) => console.log(solution(info)));
