/**
 
돌담을 쌓게 됩니다.
벽은 곧고 길이가 N미터여야 하며 두께는 일정해야 합니다.
그러나 위치에 따라 높이가 달라야 합니다.
벽의 높이는 N 양의 정수 배열 H로 지정됩니다.
H[I]는 벽의 왼쪽 끝에서 오른쪽으로 I에서 I+1미터까지의 높이입니다.
특히 H[0]은 벽의 왼쪽 끝 높이이고 H[N-1]은 벽 오른쪽 끝의 높이입니다.

벽은 직육면체 돌 블록으로 만들어야 합니다(즉, 이러한 블록의 모든 면은 직사각형입니다).
당신의 임무는 벽을 만드는 데 필요한 최소 블록 수를 계산하는 것입니다.

함수 작성:

벽의 높이를 지정하는 N 양의 정수 배열 H가 주어지면 벽을 만드는 데 필요한 최소 블록 수를 반환합니다.

예를 들어, N = 9 정수를 포함하는 배열 H가 주어진 경우:

  H[0] = 8 H[1] = 8 H[2] = 5
  H[3] = 7 H[4] = 9 H[5] = 8
  H[6] = 7 H[7] = 4 H[8] = 8
함수는 7을 반환해야 합니다. 그림은 7개 블록의 가능한 배열을 보여줍니다.

다음 가정에 대한 효율적인 알고리즘을 작성 하십시오.

N은 범위 [ 1 .. 100,000 ] 내의 정수 이고;
배열 H의 각 요소는 [ 1 .. 1,000,000,000 ] 범위 내의 정수 입니다.


주어진 배열 H의 높이로 구성되는 실루엣을 만드는데 필요한 블럭의 최소 갯수를 하는 문제..
 */

/**
 
높이 값이 서로 다른 구간을 구하면 일단 되려나...?
일단 높이값이 다른 구간을 분리해보자..

시작 인덱스를 기준으로 -값이 나오는 구간 전까지 stack에 추가하고
해당 스택에서 공통으로 가질 수 있는 값 최대 값을 가져온다.
마지막 인덱스 까지 이를 반복한다.

8, 5, 7, 9, 8, 7, 4, 8;

샘플 이미지처럼 block을 구성하려고 하면 어려워짐.

satck을 이용해 이전 블럭보다 큰값이 오면 추가하며 block카운트 증가
작은 값이 오면 stack을 제거해서 비운 후 stack추가 작업을 추가


 * @param {*} H
 */
function solution(H) {
  console.log(H);

  const blocks = [];
  const len = H.length;
  let count = 0;
  let idx = 0;

  while (idx < len) {
    // 기준값 추출
    const h = H[idx];
    // stack에 값이 존재하면 현재값과 비교 후 더 크면 스택을 제거
    while (blocks.length && blocks[blocks.length - 1] > h) {
      blocks.pop();
    }
    // stack이 비어 있거나 현재 값이 더 크면 스택에 추가하며 count증가
    if (!blocks.length || blocks[blocks.length - 1] < h) {
      console.log("push-h", h);
      blocks.push(h);
      count++;
    }
    idx++;
  }
  console.log("count", count, "blocks", blocks);
}

solution([8, 8, 5, 7, 9, 8, 7, 4, 8]);
/**
 * stack.push(8)
 * stack.pop()
 */
